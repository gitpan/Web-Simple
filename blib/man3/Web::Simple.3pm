.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Web::Simple 3"
.TH Web::Simple 3 "2011-02-15" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Web::Simple \- A quick and easy way to build simple web applications
.SH "WARNING"
.IX Header "WARNING"
This is really quite new. If you're reading this on \s-1CPAN\s0, it means the stuff
that's here we're probably happy with. But only probably. So we may have to
change stuff. And if you're reading this from git, come check with irc.perl.org
#web\-simple that we're actually sure we're going to keep anything that's
different from the \s-1CPAN\s0 version.
.PP
If we do find we have to change stuff we'll add to the
\&\*(L"\s-1CHANGES\s0 \s-1BETWEEN\s0 \s-1RELEASES\s0\*(R" section explaining how to switch your code across
to the new version, and we'll do our best to make it as painless as possible
because we've got Web::Simple applications too. But we can't promise not to
change things at all. Not yet. Sorry.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!/usr/bin/env perl
\&
\&  use Web::Simple \*(AqHelloWorld\*(Aq;
\&
\&  {
\&    package HelloWorld;
\&
\&    sub dispatch_request {
\&      sub (GET) {
\&        [ 200, [ \*(AqContent\-type\*(Aq, \*(Aqtext/plain\*(Aq ], [ \*(AqHello world!\*(Aq ] ]
\&      },
\&      sub () {
\&        [ 405, [ \*(AqContent\-type\*(Aq, \*(Aqtext/plain\*(Aq ], [ \*(AqMethod not allowed\*(Aq ] ]
\&      }
\&    }
\&  }
\&
\&  HelloWorld\->run_if_script;
.Ve
.PP
If you save this file into your cgi-bin as \f(CW\*(C`hello\-world.cgi\*(C'\fR and then visit:
.PP
.Vb 1
\&  http://my.server.name/cgi\-bin/hello\-world.cgi/
.Ve
.PP
you'll get the \*(L"Hello world!\*(R" string output to your browser. For more complex
examples and non-CGI deployment, see below. To get help with Web::Simple,
please connect to the irc.perl.org \s-1IRC\s0 network and join #web\-simple.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The philosophy of Web::Simple is to keep to an absolute bare minimum for
everything. It is not designed to be used for large scale applications;
the Catalyst web framework already works very nicely for that and is
a far more mature, well supported piece of software.
.PP
However, if you have an application that only does a couple of things, and
want to not have to think about complexities of deployment, then Web::Simple
might be just the thing for you.
.PP
The only public interface the Web::Simple module itself provides is an
\&\f(CW\*(C`import\*(C'\fR based one:
.PP
.Vb 1
\&  use Web::Simple \*(AqNameOfApplication\*(Aq;
.Ve
.PP
This sets up your package (in this case \*(L"NameOfApplication\*(R" is your package)
so that it inherits from Web::Simple::Application and imports strictures,
as well as installs a \f(CW\*(C`PSGI_ENV\*(C'\fR constant for convenience, as well as some 
other subroutines.
.PP
Importing strictures will automatically make your code use the \f(CW\*(C`strict\*(C'\fR and
\&\f(CW\*(C`warnings\*(C'\fR pragma, so you can skip the usual:
.PP
.Vb 2
\&  use strict;
\&  use warnings FATAL => \*(Aqaa\*(Aq;
.Ve
.PP
provided you 'use Web::Simple' at the top of the file. Note that we turn
on *fatal* warnings so if you have any warnings at any point from the file
that you did 'use Web::Simple' in, then your application will die. This is,
so far, considered a feature.
.PP
When we inherit from Web::Simple::Application we also use <Moo>, which is
the the equivalent of:
.PP
.Vb 5
\&  {
\&    package NameOfApplication;
\&    use Moo;
\&    extends \*(AqWeb::Simple::Application\*(Aq;
\&  }
.Ve
.PP
So you can use Moo features in your application, such as creating attributes
using the \f(CW\*(C`has\*(C'\fR subroutine, etc.  Please see the documentation for Moo for
more information.
.PP
It also exports the following subroutines for use in dispatchers:
.PP
.Vb 1
\&  response_filter { ... };
\&
\&  redispatch_to \*(Aq/somewhere\*(Aq;
.Ve
.PP
Finally, import sets
.PP
.Vb 1
\&  $INC{"NameOfApplication.pm"} = \*(AqSet by "use Web::Simple;" invocation\*(Aq;
.Ve
.PP
so that perl will not attempt to load the application again even if
.PP
.Vb 1
\&  require NameOfApplication;
.Ve
.PP
is encountered in other code.
.SH "DISPATCH STRATEGY"
.IX Header "DISPATCH STRATEGY"
Web::Simple despite being straightforward to use, has a powerful system
for matching all sorts of incoming URLs to one or more subroutines.  These
subroutines can be simple actions to take for a given \s-1URL\s0, or something
more complicated, including entire Plack applications, Plack::Middleware
and nested subdispatchers.
.SS "Examples"
.IX Subsection "Examples"
.Vb 10
\& sub dispatch_request {
\&   # matches: GET /user/1.htm?show_details=1
\&   #          GET /user/1.htm
\&   sub (GET + /user/* + ?show_details~ + .htm|.html|.xhtml) {
\&     my ($self, $user_id, $show_details) = @_;
\&     ...
\&   },
\&   # matches: POST /user?username=frew
\&   #          POST /user?username=mst&first_name=matt&last_name=trout
\&   sub (POST + /user + ?username=&*) {
\&      my ($self, $username, $misc_params) = @_;
\&     ...
\&   },
\&   # matches: DELETE /user/1/friend/2
\&   sub (DELETE + /user/*/friend/*) {
\&     my ($self, $user_id, $friend_id) = @_;
\&     ...
\&   },
\&   # matches: PUT /user/1?first_name=Matt&last_name=Trout
\&   sub (PUT + /user/* + ?first_name~&last_name~) {
\&     my ($self, $user_id, $first_name, $last_name) = @_;
\&     ...
\&   },
\&   sub (/user/*/...) {
\&     my $user_id = $_[1];
\&     # matches: PUT /user/1/role/1
\&     sub (PUT + /role/*) {
\&       my $role_id = $_[1];
\&       ...
\&     },
\&     # matches: DELETE /user/1/role/1
\&     sub (DELETE + /role/*) {
\&       my $role_id = $_[1];
\&       ...
\&     },
\&   },
\& }
.Ve
.SS "The dispatch cycle"
.IX Subsection "The dispatch cycle"
At the beginning of a request, your app's dispatch_request method is called
with the \s-1PSGI\s0 \f(CW$env\fR as an argument. You can handle the request entirely in
here and return a \s-1PSGI\s0 response arrayref if you want:
.PP
.Vb 4
\&  sub dispatch_request {
\&    my ($self, $env) = @_;
\&    [ 404, [ \*(AqContent\-type\*(Aq => \*(Aqtext/plain\*(Aq ], [ \*(AqAmnesia == fail\*(Aq ] ]
\&  }
.Ve
.PP
However, generally, instead of that, you return a set of dispatch subs:
.PP
.Vb 6
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (/) { redispatch_to \*(Aq/index.html\*(Aq },
\&    sub (/user/*) { $self\->show_user($_[1]) },
\&    ...
\&  }
.Ve
.PP
If you return a subroutine with a prototype, the prototype is treated
as a match specification \- and if the test is passed, the body of the
sub is called as a method any matched arguments (see below for more details).
.PP
You can also return a plain subroutine which will be called with just \f(CW$env\fR
\&\- remember that in this case if you need \f(CW$self\fR you \-must\- close over it.
.PP
If you return a normal object, Web::Simple will simply return it upwards on
the assumption that a response_filter (or some arbitrary Plack::Middleware)
somewhere will convert it to something useful.  This allows:
.PP
.Vb 5
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (.html) { response_filter { $self\->render_zoom($_[0]) } },
\&    sub (/user/*) { $self\->users\->get($_[1]) },
\&  }
.Ve
.PP
to render a user object to \s-1HTML\s0, if there is an incoming \s-1URL\s0 such as:
.PP
.Vb 1
\&  http://myweb.org/user/111.html
.Ve
.PP
This works because as we descend down the dispachers, we first match
\&\f(CW\*(C`sub (.html)\*(C'\fR, which adds a \f(CW\*(C`response_filter\*(C'\fR (basically a specialized routine
that follows the Plack::Middleware specification), and then later we also
match \f(CW\*(C`sub (/user/*)\*(C'\fR which gets a user and returns that as the response.
This user object 'bubbles up' through all the wrapping middleware until it hits
the \f(CW\*(C`response_filter\*(C'\fR we defined, after which the return is converted to a
true html response.
.PP
However, two types of object are treated specially \- a Plack::App object
will have its \f(CW\*(C`\-\*(C'\fRto_app> method called and be used as a dispatcher:
.PP
.Vb 5
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (/static/...) { Plack::App::File\->new(...) },
\&    ...
\&  }
.Ve
.PP
A Plack::Middleware object will be used as a filter for the rest of the
dispatch being returned into:
.PP
.Vb 1
\&  ## responds to /admin/track_usage AND /admin/delete_accounts
\&
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (/admin/**) {
\&      Plack::Middleware::Session\->new(%opts);
\&    },
\&    sub (/admin/track_usage) {
\&      ## something that needs a session
\&    },
\&    sub (/admin/delete_accounts) {
\&      ## something else that needs a session
\&    },
\&  }
.Ve
.PP
Note that this is for the dispatch being \-returned\- to, so if you want to
provide it inline you need to do:
.PP
.Vb 1
\&  ## ALSO responds to /admin/track_usage AND /admin/delete_accounts
\&
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (/admin/...) {
\&      sub {
\&        Plack::Middleware::Session\->new(%opts);
\&      },
\&      sub (/track_usage) {
\&        ## something that needs a session
\&      },
\&      sub (/delete_accounts) {
\&        ## something else that needs a session
\&      },
\&    }
\&  }
.Ve
.PP
And that's it \- but remember that all this happens recursively \- it's
dispatchers all the way down.  A \s-1URL\s0 incoming pattern will run all matching
dispatchers and then hit all added filters or Plack::Middleware.
.SS "Web::Simple match specifications"
.IX Subsection "Web::Simple match specifications"
\fIMethod matches\fR
.IX Subsection "Method matches"
.PP
.Vb 1
\&  sub (GET) {
.Ve
.PP
A match specification beginning with a capital letter matches \s-1HTTP\s0 requests
with that request method.
.PP
\fIPath matches\fR
.IX Subsection "Path matches"
.PP
.Vb 1
\&  sub (/login) {
.Ve
.PP
A match specification beginning with a / is a path match. In the simplest
case it matches a specific path. To match a path with a wildcard part, you
can do:
.PP
.Vb 2
\&  sub (/user/*) {
\&    $self\->handle_user($_[1])
.Ve
.PP
This will match /user/<anything> where <anything> does not include a literal
/ character. The matched part becomes part of the match arguments. You can
also match more than one part:
.PP
.Vb 2
\&  sub (/user/*/*) {
\&    my ($self, $user_1, $user_2) = @_;
\&
\&  sub (/domain/*/user/*) {
\&    my ($self, $domain, $user) = @_;
.Ve
.PP
and so on. To match an arbitrary number of parts, use \-
.PP
.Vb 1
\&  sub (/page/**) {
.Ve
.PP
This will result in an element per /\-separated part so matched. Note that
you can do
.PP
.Vb 1
\&  sub (/page/**/edit) {
.Ve
.PP
to match an arbitrary number of parts up to but not including some final
part.
.PP
Finally,
.PP
.Vb 1
\&  sub (/foo/...) {
.Ve
.PP
Will match /foo/ on the beginning of the path \-and\- strip it. This is designed
to be used to construct nested dispatch structures, but can also prove useful
for having e.g. an optional language specification at the start of a path.
.PP
Note that the '...' is a \*(L"maybe something here, maybe not\*(R" so the above
specification will match like this:
.PP
.Vb 3
\&  /foo         # no match
\&  /foo/        # match and strip path to \*(Aq/\*(Aq
\&  /foo/bar/baz # match and strip path to \*(Aq/bar/baz\*(Aq
.Ve
.PP
\fIExtension matches\fR
.IX Subsection "Extension matches"
.PP
.Vb 1
\&  sub (.html) {
.Ve
.PP
will match .html from the path (assuming the subroutine itself returns
something, of course). This is normally used for rendering \- e.g.
.PP
.Vb 3
\&  sub (.html) {
\&    response_filter { $self\->render_html($_[1]) }
\&  }
.Ve
.PP
Additionally,
.PP
.Vb 1
\&  sub (.*) {
.Ve
.PP
will match any extension and supplies the extension as a match argument.
.PP
\fIQuery and body parameter matches\fR
.IX Subsection "Query and body parameter matches"
.PP
Query and body parameters can be match via
.PP
.Vb 2
\&  sub (?<param spec>) { # match URI query
\&  sub (%<param spec>) { # match body params
.Ve
.PP
The body is only matched if the content type is
application/x\-www\-form\-urlencoded (note this means that Web::Simple does
not yet handle uploads; this will be addressed in a later release).
.PP
The param spec is elements of one of the following forms \-
.PP
.Vb 10
\&  param~        # optional parameter
\&  param=        # required parameter
\&  @param~       # optional multiple parameter
\&  @param=       # required multiple parameter
\&  :param~       # optional parameter in hashref
\&  :param=       # required parameter in hashref
\&  :@param~      # optional multiple in hashref
\&  :@param=      # required multiple in hashref
\&  *             # include all other parameters in hashref
\&  @*            # include all other parameters as multiple in hashref
.Ve
.PP
separated by the & character. The arguments added to the request are
one per non\-:/* parameter (scalar for normal, arrayref for multiple),
plus if any :/* specs exist a hashref containing those values.
.PP
Please note that if you specify a multiple type parameter match, you are
ensured of getting an arrayref for the value, \s-1EVEN\s0 if the current incoming
request has only one value.  However if a parameter is specified as single
and multiple values are found, the last one will be used.
.PP
For example to match a page parameter with an optional order_by parameter one
would write:
.PP
.Vb 8
\&  sub (?page=&order_by~) {
\&    my ($self, $page, $order_by) = @_;
\&    return unless $page =~ /^\ed+$/;
\&    $page ||= \*(Aqid\*(Aq;
\&    response_filter {
\&      $_[1]\->search_rs({}, $p);
\&    }
\&  }
.Ve
.PP
to implement paging and ordering against a DBIx::Class::ResultSet object.
.PP
Another Example: To get all parameters as a hashref of arrayrefs, write:
.PP
.Vb 3
\&  sub(?@*) {
\&    my ($self, $params) = @_;
\&    ...
.Ve
.PP
To get two parameters as a hashref, write:
.PP
.Vb 2
\&  sub(?:user~&:domain~) {
\&    my ($self, $params) = @_; # params contains only \*(Aquser\*(Aq and \*(Aqdomain\*(Aq keys
.Ve
.PP
You can also mix these, so:
.PP
.Vb 2
\&  sub (?foo=&@bar~&:coffee=&@*) {
\&     my ($self, $foo, $bar, $params);
.Ve
.PP
where \f(CW$bar\fR is an arrayref (possibly an empty one), and \f(CW$params\fR contains
arrayref values for all parameters \-not\- mentioned and a scalar value for
the 'coffee' parameter.
.PP
Note, in the case where you combine arrayref, single parameter and named
hashref style, the arrayref and single parameters will appear in \f(CW@_\fR in the
order you defined them in the protoype, but all hashrefs will merge into a 
single \f(CW$params\fR, as in the example above.
.PP
\fICombining matches\fR
.IX Subsection "Combining matches"
.PP
Matches may be combined with the + character \- e.g.
.PP
.Vb 1
\&  sub (GET + /user/*) {
.Ve
.PP
to create an \s-1AND\s0 match. They may also be combined withe the | character \- e.g.
.PP
.Vb 1
\&  sub (GET|POST) {
.Ve
.PP
to create an \s-1OR\s0 match. Matches can be nested with () \- e.g.
.PP
.Vb 1
\&  sub ((GET|POST) + /user/*) {
.Ve
.PP
and negated with ! \- e.g.
.PP
.Vb 1
\&  sub (!/user/foo + /user/*) {
.Ve
.PP
! binds to the immediate rightmost match specification, so if you want
to negate a combination you will need to use
.PP
.Vb 1
\&  sub ( !(POST|PUT|DELETE) ) {
.Ve
.PP
and | binds tighter than +, so
.PP
.Vb 1
\&  sub ((GET|POST) + /user/*) {
.Ve
.PP
and
.PP
.Vb 1
\&  sub (GET|POST + /user/*) {
.Ve
.PP
are equivalent, but
.PP
.Vb 1
\&  sub ((GET + /admin/...) | (POST + /admin/...)) {
.Ve
.PP
and
.PP
.Vb 1
\&  sub (GET + /admin/... | POST + /admin/...) {
.Ve
.PP
are not \- the latter is equivalent to
.PP
.Vb 1
\&  sub (GET + (/admin/...|POST) + /admin/...) {
.Ve
.PP
which will never match!
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
Note that for legibility you are permitted to use whitespace \-
.PP
.Vb 1
\&  sub (GET + /user/*) {
.Ve
.PP
but it will be ignored. This is because the perl parser strips whitespace
from subroutine prototypes, so this is equivalent to
.PP
.Vb 1
\&  sub (GET+/user/*) {
.Ve
.PP
\fIAccessing the \s-1PSGI\s0 env hash\fR
.IX Subsection "Accessing the PSGI env hash"
.PP
In some cases you may wish to get the raw \s-1PSGI\s0 env hash \- to do this,
you can either use a plain sub \-
.PP
.Vb 4
\&  sub {
\&    my ($env) = @_;
\&    ...
\&  }
.Ve
.PP
or use the \s-1PSGI_ENV\s0 constant exported to retrieve it:
.PP
.Vb 4
\&  sub (GET + /foo + ?some_param=) {
\&    my $param = $_[1];
\&    my $env = $_[PSGI_ENV];
\&  }
.Ve
.PP
but note that if you're trying to add a middleware, you should simply use
Web::Simple's direct support for doing so.
.SH "EXPORTED SUBROUTINES"
.IX Header "EXPORTED SUBROUTINES"
.SS "response_filter"
.IX Subsection "response_filter"
.Vb 7
\&  response_filter {
\&    # Hide errors from the user because we hates them, preciousss
\&    if (ref($_[0]) eq \*(AqARRAY\*(Aq && $_[0]\->[0] == 500) {
\&      $_[0] = [ 200, @{$_[0]}[1..$#{$_[0]}] ];
\&    }
\&    return $_[0];
\&  };
.Ve
.PP
The response_filter subroutine is designed for use inside dispatch subroutines.
.PP
It creates and returns a special dispatcher that always matches, and calls
the block passed to it as a filter on the result of running the rest of the
current dispatch chain.
.PP
Thus the filter above runs further dispatch as normal, but if the result of
dispatch is a 500 (Internal Server Error) response, changes this to a 200 (\s-1OK\s0)
response without altering the headers or body.
.SS "redispatch_to"
.IX Subsection "redispatch_to"
.Vb 1
\&  redispatch_to \*(Aq/other/url\*(Aq;
.Ve
.PP
The redispatch_to subroutine is designed for use inside dispatch subroutines.
.PP
It creates and returns a special dispatcher that always matches, and instead
of continuing dispatch re-delegates it to the start of the dispatch process,
but with the path of the request altered to the supplied \s-1URL\s0.
.PP
Thus if you receive a \s-1POST\s0 to '/some/url' and return a redispatch to
\&'/other/url', the dispatch behaviour will be exactly as if the same \s-1POST\s0
request had been made to '/other/url' instead.
.PP
Note, this is not the same as returning an \s-1HTTP\s0 3xx redirect as a response;
rather it is a much more efficient internal process.
.SH "CHANGES BETWEEN RELEASES"
.IX Header "CHANGES BETWEEN RELEASES"
.SS "Changes between 0.004 and 0.005"
.IX Subsection "Changes between 0.004 and 0.005"
.IP "\(bu" 4
dispatch {} replaced by declaring a dispatch_request method
.Sp
dispatch {} has gone away \- instead, you write:
.Sp
.Vb 5
\&  sub dispatch_request {
\&    my $self = shift;
\&    sub (GET /foo/) { ... },
\&    ...
\&  }
.Ve
.Sp
Note that this method is still \-returning\- the dispatch code \- just like
dispatch did.
.Sp
Also note that you need the 'my \f(CW$self\fR = shift' since the magic \f(CW$self\fR
variable went away.
.IP "\(bu" 4
the magic \f(CW$self\fR variable went away.
.Sp
Just add 'my \f(CW$self\fR = shift;' while writing your 'sub dispatch_request {'
like a normal perl method.
.IP "\(bu" 4
subdispatch deleted \- all dispatchers can now subdispatch
.Sp
In earlier releases you needed to write:
.Sp
.Vb 7
\&  subdispatch sub (/foo/...) {
\&    ...
\&    [
\&      sub (GET /bar/) { ... },
\&      ...
\&    ]
\&  }
.Ve
.Sp
As of 0.005, you can instead write simply:
.Sp
.Vb 7
\&  sub (/foo/...) {
\&    ...
\&    (
\&      sub (GET /bar/) { ... },
\&      ...
\&    )
\&  }
.Ve
.SS "Changes since Antiquated Perl"
.IX Subsection "Changes since Antiquated Perl"
.IP "\(bu" 4
filter_response renamed to response_filter
.Sp
This is a pure rename; a global search and replace should fix it.
.IP "\(bu" 4
dispatch [] changed to dispatch {}
.Sp
Simply changing
.Sp
.Vb 1
\&  dispatch [ sub(...) { ... }, ... ];
.Ve
.Sp
to
.Sp
.Vb 1
\&  dispatch { sub(...) { ... }, ... };
.Ve
.Sp
should work fine.
.SH "DEVELOPMENT HISTORY"
.IX Header "DEVELOPMENT HISTORY"
Web::Simple was originally written to form part of my Antiquated Perl talk for
Italian Perl Workshop 2009, but in writing the bloggery example I realised
that having a bare minimum system for writing web applications that doesn't
drive me insane was rather nice and decided to spend my attempt at nanowrimo
for 2009 improving and documenting it to the point where others could use it.
.PP
The Antiquated Perl talk can be found at <http://www.shadowcat.co.uk/archive/conference\-video/>.
.SH "COMMUNITY AND SUPPORT"
.IX Header "COMMUNITY AND SUPPORT"
.SS "\s-1IRC\s0 channel"
.IX Subsection "IRC channel"
irc.perl.org #web\-simple
.SS "No mailing list yet"
.IX Subsection "No mailing list yet"
Because mst's non-work email is a bombsite so he'd never read it anyway.
.SS "Git repository"
.IX Subsection "Git repository"
Gitweb is on http://git.shadowcat.co.uk/ and the clone \s-1URL\s0 is:
.PP
.Vb 1
\&  git clone git://git.shadowcat.co.uk/catagits/Web\-Simple.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt S. Trout <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
None required yet. Maybe this module is perfect (hahahahaha ...).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010 the Web::Simple \*(L"\s-1AUTHOR\s0\*(R" and \*(L"\s-1CONTRIBUTORS\s0\*(R"
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 599:" 4
.IX Item "Around line 599:"
You forgot a '=back' before '=head2'
